package uk.org.nbn.nbnv.api.authentication;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.security.*;
import java.util.Arrays;
import java.util.Calendar;
import javax.crypto.*;
import javax.crypto.spec.IvParameterSpec;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import uk.org.nbn.nbnv.api.dao.mappers.UserAuthenticationMapper;
import uk.org.nbn.nbnv.api.model.User;

/**
 * The following is a Simple token authentication and token generator powered by
 * the NBN Gateway database.
 *
 * This Token Authenticator is configured as a Spring Bean
 * 
 * For a details description of the byte structure of the tokens generated by 
 * this class, @see NBNTokenAuthenticator#generateToken(byte[], int)
 * @author Christopher Johnson
 */
@Component
public class NBNTokenAuthenticator implements TokenAuthenticator {
    private static final int INITALIZATION_VECTOR_SIZE = 16;
    private static final int KEY_CHECK_VALUE_SIZE = 16;
    private static final String CREDENTIALS_DIGEST = "SHA-1";
    private static final String SECRET_KEY_ALGORITHM = "AES";
    private static final String CRYPTO_ALGORITHM = "AES/CBC/PKCS5Padding";
    private static final String STRING_ENCODING = "UTF-8";

    private final SecureRandom random;
    private final byte[] keyCheckValue;
    private final MessageDigest credentialsDigest;
    private final SecretKey key;
    
    @Autowired UserAuthenticationMapper userAuthentication;
    
    /**
     * The following constructor will generate a random key check value and
     * @see #SECRET_KEY_ALGORITHM key for encrypting tokens
     * @throws NoSuchAlgorithmException
     * @throws NoSuchPaddingException
     * @throws InvalidKeyException
     * @throws InvalidAlgorithmParameterException 
     */
    public NBNTokenAuthenticator() throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {
        this.key = KeyGenerator.getInstance(SECRET_KEY_ALGORITHM).generateKey();
        this.credentialsDigest = MessageDigest.getInstance(CREDENTIALS_DIGEST);
        this.random = new SecureRandom();
        this.keyCheckValue = randomBytes(KEY_CHECK_VALUE_SIZE);
    }

    /**
     * The following method supports the generation of tokens for username and 
     * password pairs
     * @param username The username of the principle
     * @param password The password of the principle
     * @param ttl The time this token should live for
     * @return The Token which can be reused by this class for obtaining a user
     *  @see #getUser(uk.org.nbn.nbnv.api.authentication.Token) 
     * @throws InvalidCredentialsException if the username and password are 
     *  invalid
     */
    @Override public Token generateToken(String username, String password, int ttl) throws InvalidCredentialsException {
        try {
            byte[] usernameHash = credentialsDigest.digest(username.getBytes(STRING_ENCODING));
            if(userAuthentication.isUser(usernameHash, credentialsDigest.digest(password.getBytes(STRING_ENCODING)))) //check credentials are okay
                return generateToken(usernameHash, ttl);
            else
                throw new InvalidCredentialsException("Invalid username and/or password");
        } catch (InvalidKeyException ex) {
            throw new RuntimeException("A configuration error has occurred", ex);
        } catch (NoSuchAlgorithmException ex) {
            throw new RuntimeException("A configuration error has occurred", ex);
        } catch (NoSuchPaddingException ex) {
            throw new RuntimeException("A configuration error has occurred", ex);
        } catch (UnsupportedEncodingException ex) {
            throw new RuntimeException("A configuration error has occurred", ex);
        }
    }
    
    /**
     * The following method supports the generation of tokens for web services
     * which use an md5 hash of a password to log in.
     * @param username The username of the principle
     * @param md5Hash A md5hash of a users password
     * @param ttl The time this token should live for
     * @return The Token which can be reused by this class for obtaining a user
     *  @see #getUser(uk.org.nbn.nbnv.api.authentication.Token) 
     * @throws InvalidCredentialsException if the username and md5Hash are invalid
     */
    @Override public Token generateToken(String username, byte[] md5Hash, int ttl) throws InvalidCredentialsException {
        try {
            byte[] usernameHash = credentialsDigest.digest(username.getBytes(STRING_ENCODING));
            if(userAuthentication.isUserMD5(usernameHash, credentialsDigest.digest(md5Hash))) //check credentials are okay
                return generateToken(usernameHash, ttl);
            else
                throw new InvalidCredentialsException("Invalid username and/or password");
        } catch (InvalidKeyException ex) {
            throw new RuntimeException("A configuration error has occurred", ex);
        } catch (NoSuchAlgorithmException ex) {
            throw new RuntimeException("A configuration error has occurred", ex);
        } catch (NoSuchPaddingException ex) {
            throw new RuntimeException("A configuration error has occurred", ex);
        } catch (UnsupportedEncodingException ex) {
            throw new RuntimeException("A configuration error has occurred", ex);
        }
    }

    /**
     * The following method will obtain a user object for a given token
     * @param token The token which represents a particular user
     * @return The user which this token represents
     * @throws InvalidTokenException If the token is not of this authority
     * @throws ExpiredTokenException If the token is no longer valid
     */
    @Override public User getUser(Token token) throws InvalidTokenException, ExpiredTokenException {
        try {
            if(token.getBytes().length > INITALIZATION_VECTOR_SIZE) {
                ByteBuffer message = ByteBuffer.wrap(token.getBytes());

                Cipher decrypt = Cipher.getInstance(CRYPTO_ALGORITHM);
                decrypt.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec( getBytes(message, INITALIZATION_VECTOR_SIZE) ));

                ByteBuffer payload = ByteBuffer.wrap(decrypt.doFinal(getBytes(message, message.remaining())));
                //Check if the first set of bytes is the same key check value
                if(Arrays.equals(keyCheckValue, getBytes(payload, KEY_CHECK_VALUE_SIZE))) {
                    if(payload.getLong() >= Calendar.getInstance().getTimeInMillis())  //is ticket still valid
                        return userAuthentication.getUser(getBytes(payload, payload.remaining()));
                    else 
                        throw new ExpiredTokenException("No longer valid");
                }
            }
            throw new InvalidTokenException("Invalid composite key");
        } catch (NoSuchAlgorithmException ex) {
            throw new RuntimeException("A configuration error has occurred", ex);
        } catch (NoSuchPaddingException ex) {
            throw new RuntimeException("A configuration error has occurred", ex);
        } catch (InvalidKeyException ex) {
            throw new InvalidTokenException("Invalid composite key");
        } catch (InvalidAlgorithmParameterException ex) {
            throw new InvalidTokenException("Invalid composite key");
        } catch (IllegalBlockSizeException ibse) {
            throw new InvalidTokenException("Invalid composite key");
        } catch (BadPaddingException bpe) {
            throw new InvalidTokenException("Invalid composite key");
        }
    }

    /**
     * The following method will perform a SECRET_KEY_ALGORITHM encryption of
     * the following structure.
     * 
     * The byte structure of a token generated by this class is :
     *      BYTE_ARRAY_LENGTH           |                   CONTENT
     * -----------------------------------------------------------------------
     * ---------------------------- PLAINTEXT --------------------------------
     *  @see #INITALIZATION_VECTOR_SIZE | The vector used for the message
     * --------------------------- CIPHER TEXT -------------------------------
     *  @see #KEY_CHECK_VALUE_SIZE      | Randomly generated id for this 
     *                                  |   TokenAuthenticator
     *  8 (byte size of long)           | The time in milliseconds from epoch 
     *                                  | when this token expires
     *  @see #USERNAME_HASH_SIZE        | A hash of the principles username in 
     *                                  |   @see #CREDENTIALS_DIGEST
     * 
     * @param usernameHash The hash of the username in @see #CREDENTIALS_DIGEST
     * @param ttl Time in milliseconds until this token expires
     * @return An Token object with the above byte structure encrypted in 
     *  @see #SECRET_KEY_ALGORITHM
     */
    private Token generateToken(byte[] usernameHash, int ttl) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException {
        try {
            Cipher encrypt = Cipher.getInstance(CRYPTO_ALGORITHM);
            encrypt.init(Cipher.ENCRYPT_MODE, key);
            
            byte[] payload = encrypt.doFinal(ByteBuffer.allocate(KEY_CHECK_VALUE_SIZE + 8 + usernameHash.length) //Encrypt byte buffer
                .put(keyCheckValue)                                         //store key check
                .putLong(Calendar.getInstance().getTimeInMillis() + ttl)    //Store the time when this token becomes invalid
                .put(usernameHash)                                          //Store username hash
                .array()
            );                    
            
            return new Token(ByteBuffer.allocate(INITALIZATION_VECTOR_SIZE + payload.length)
                .put(encrypt.getIV())
                .put(payload)
                .array()
            );
        } catch (IllegalBlockSizeException ex) {
            throw new RuntimeException("A configuration error has occurred", ex);
        } catch (BadPaddingException ex) {
            throw new RuntimeException("A configuration error has occurred", ex);
        }
    }
    
    /**
     * Utility method to read a byte array of size from a ByteBuffer
     * @param buf The buffer to read from
     * @param size The amount of bytes to read
     * @return A byte array of bytes read from the buffer
     */
    private static byte[] getBytes(ByteBuffer buf, int size) {
        byte[] toReturn = new byte[size];
        buf.get(toReturn);
        return toReturn;
    }
    
    /**
     * Utility method to create a byte array of a specified size full of random
     * bytes
     * @param size The amount of bytes to randomly create
     * @return A byte array of random bytes
     */
    private byte[] randomBytes(int size) {
        byte[] nonce = new byte[size];
        random.nextBytes(nonce);
        return nonce;
    }
}
