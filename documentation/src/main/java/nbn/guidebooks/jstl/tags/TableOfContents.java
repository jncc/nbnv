
package nbn.guidebooks.jstl.tags;

import java.util.HashSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.servlet.jsp.tagext.*;
import javax.servlet.jsp.*;

/**
 * This class will generate the HTML for a table of contents and a its corresponding
 * content for a given fragment of HTML.
 * @warning The id's generated for a given
 * @author Christopher Johnson
 */
public class TableOfContents extends BodyTagSupport {
    private static final Pattern TAG_SELECTOR_PATTERN = Pattern.compile("<[^>]*>");
    private static final Pattern OPENING_TAG_ID_PATTERN = Pattern.compile("id=\".*\"");
    private static final Pattern HEADER_PATTERN = Pattern.compile("<h[1-9][^>]*>.*?<\\/h[1-9]>");

    private static final String OPEN_LIST_TAG = "<ol>";
    private static final String CLOSE_LIST_TAG = "</ol>";

    private static final int INFINITE_DEPTH = -1;
    private String tocVariableName, fragmentVariableName;

    private HashSet<String> takenIDs = new HashSet<String>();
    private int maximumDepth = INFINITE_DEPTH;
    
    public void setToc(String tocVariableName) {
        this.tocVariableName = tocVariableName;
    }

    public void setFragment(String fragmentVariableName) {
        this.fragmentVariableName = fragmentVariableName;
    }

    public void setDepth(int maximumDepth) {
        this.maximumDepth = maximumDepth;
    }

    @Override
    public int doAfterBody() throws JspException {
        String htmlString = bodyContent.getString(); //get the body as a string
        Matcher m = HEADER_PATTERN.matcher(htmlString);
        StringBuffer frag = new StringBuffer(htmlString.length());
        StringBuilder toc = new StringBuilder(OPEN_LIST_TAG);
        int currentHeaderDepth = 1;//set the starting counter to the lowest header value. i.e. <h1>
        while (m.find()) {
            HeaderTag text = new HeaderTag(m.group()); //construct a new header tag
            
            registerIDAsTaken(text.id); //register the ID as being taken
            int deltaDepth = currentHeaderDepth - text.headerLevel; //open and close lists as nessersary
  
            if(maximumDepth == INFINITE_DEPTH || maximumDepth >= text.headerLevel) {
                currentHeaderDepth = text.headerLevel; //store the current header level
                if      (deltaDepth < 0) appendMultipleTimes(toc, Math.abs(deltaDepth), OPEN_LIST_TAG);
                else if (deltaDepth > 0) appendMultipleTimes(toc, deltaDepth, CLOSE_LIST_TAG);

                toc.append("<li><a href=\"#").append(text.id).append("\">") //create a new list entry
                    .append(text.name)
                    .append("</a></li>");
            }

            m.appendReplacement(frag, Matcher.quoteReplacement(text.fullTag));
        }
        appendMultipleTimes(toc, currentHeaderDepth-1, CLOSE_LIST_TAG); //close all open lists
        m.appendTail(frag);

        pageContext.setAttribute(tocVariableName, toc.toString());  //post out results
        pageContext.setAttribute(fragmentVariableName, frag.toString());
        return SKIP_BODY;
    }

    private void registerIDAsTaken(String idToTake) throws JspException {
        if(!takenIDs.add(idToTake))
            throw new JspException("An id which has been manually set in the HTML fragment conflicts with one generated by this class. To avoid this, don't use id's which match the names of sections of your fragment.");
    }

    private String getAvaliableUniqueID(String tendTo) {
        String toUse = tendTo.replaceAll(" ",""); //remove spaces from the string so that it can be used as an ID
        String attemptToUse = toUse;
        for (int i=1; takenIDs.contains(attemptToUse); i++) //loop around if there are conflicts
            attemptToUse = toUse + i;

        return attemptToUse; 
    }

    private class HeaderTag {
        private String fullTag, id, name;
        private int headerLevel;

        public HeaderTag(String fullTag) {
            this.fullTag = fullTag;
            this.headerLevel = Character.getNumericValue(fullTag.charAt(2)); //get the header level
            Matcher m = TAG_SELECTOR_PATTERN.matcher(fullTag);//get the opening tag to check/insert id
            if(!m.find()) throw new IllegalArgumentException("A header tag should only be constructed with a full header tag");
            String openingTag = m.group(); //creating the id requires the name to be set, store opening tag for later
            this.name = m.replaceAll(""); //delete all found tags to create the name
            this.id = generateID(openingTag);
        }

        private String generateID(String openingTag) {
            Matcher m = OPENING_TAG_ID_PATTERN.matcher(openingTag);
            if(m.find()) { //tag has been found
                String found = m.group();
                return found.substring(4,found.length()-1); //already has an id
            }
            else { //need to generate a id
                String generatedID = getAvaliableUniqueID(name);
                fullTag = new StringBuilder(fullTag)
                        .insert(openingTag.length()-1," id=\"" + generatedID + "\"")
                        .toString();
                return generatedID;
            }
        }
    }

    /**Helper method to perform a stringbuilder append multiple times**/
    private static void appendMultipleTimes(StringBuilder toAppendTo, int times, String toAppend) {
        for(int i=0; i<times; i++) toAppendTo.append(toAppend);
    }
}